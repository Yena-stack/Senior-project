# -*- coding: utf-8 -*-
"""pascal_dataset.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1UXBOpM_OAU2wAz2kptjoTzeaZYhLj76m
"""

import torch
from torchvision.models.detection import fasterrcnn_resnet50_fpn
from torchvision.transforms import functional as F
from torchvision.datasets import VOCDetection
from torch.utils.data import DataLoader
from torch.utils.data.sampler import RandomSampler
from engine import train_one_epoch, evaluate
import utils

device = torch.device('cuda') if torch.cuda.is_available() else torch.device('cpu')

root_dir = 'path/to/VOCdevkit'  # Path to the VOCdevkit directory

# Define dataset transforms
transform = lambda image, target: (F.to_tensor(image), target)

# Create train and test datasets
train_dataset = VOCDetection(root_dir, year='2012', image_set='train', transform=transform)
test_dataset = VOCDetection(root_dir, year='2012', image_set='val', transform=transform)

# Create data loaders
train_loader = DataLoader(train_dataset, batch_size=2, shuffle=True, collate_fn=utils.collate_fn)
test_loader = DataLoader(test_dataset, batch_size=1, shuffle=False, collate_fn=utils.collate_fn)

# Load pre-trained model
model = fasterrcnn_resnet50_fpn(pretrained=True)
num_classes = len(train_dataset.classes)
in_features = model.roi_heads.box_predictor.cls_score.in_features
model.roi_heads.box_predictor = torch.nn.Linear(in_features, num_classes + 1)  # +1 for background class

# Move model to device
model.to(device)

# Set optimizer and learning rate scheduler
params = [p for p in model.parameters() if p.requires_grad]
optimizer = torch.optim.SGD(params, lr=0.005, momentum=0.9, weight_decay=0.0005)
lr_scheduler = torch.optim.lr_scheduler.StepLR(optimizer, step_size=3, gamma=0.1)

# Train the model
num_epochs = 10
for epoch in range(num_epochs):
    train_one_epoch(model, optimizer, train_loader, device, epoch, print_freq=10)
    lr_scheduler.step()

    # Evaluate the model
    evaluate(model, test_loader, device=device)

# Save the trained model
torch.save(model.state_dict(), 'trained_model.pth')